% openmagnetics_api_interface.m
% OpenMagnetics-compatible offline database with full wire/core/material specs
% Includes: supplier-indexed cores, wire Type/Standard/Coating/Diameter fields

classdef openmagnetics_api_interface < handle

    properties
        wire_database
        core_database
        material_database
        supplier_list      % Cell array of supplier names
        supplier_cores     % Struct: supplier -> {core names}
        supplier_materials % Struct: supplier -> {material names}
        mode = 'offline'
        online_url = 'http://localhost:8484'
        online_client
        online_connected = false
        cache_loaded = false
        cached_wire_database
        cached_core_database
        cached_material_database
        cache_path = ''
    end

    methods

        function obj = openmagnetics_api_interface()
            obj.cache_path = obj.default_cache_path();
            if ~obj.load_cache()
                obj.wire_database = obj.init_wire_database();
                obj.core_database = obj.init_core_database();
                obj.material_database = obj.init_material_database();
            end

            % Auto-load PyOpenMagnetics data from JSON exports if available
            % These override the hardcoded offline databases with much richer data
            % Generated by: python export_openmagnetics_database.py
            obj.load_wire_json();
            obj.load_core_json();
            obj.load_material_json();
            obj.load_supplier_json();

            obj.init_supplier_index();

            nw = length(fieldnames(obj.wire_database));
            nc = length(fieldnames(obj.core_database));
            nm = length(fieldnames(obj.material_database));
            ns = length(obj.supplier_list);
            fprintf('OpenMagnetics API interface initialized (offline mode)\n');
            fprintf('  Wires: %d | Cores: %d | Materials: %d | Suppliers: %d\n', nw, nc, nm, ns);
        end

        function mode = get_mode(obj)
            mode = obj.mode;
        end

        function ok = set_mode(obj, mode, url)
            ok = false;
            if nargin >= 3 && ~isempty(url)
                obj.online_url = url;
            end

            if ischar(mode) && strcmpi(mode, 'online')
                try
                    obj.online_client = om_client(obj.online_url);
                    if obj.online_client.connected
                        obj.online_connected = true;
                        obj.mode = 'online';
                        ok = obj.refresh_from_online();
                        if ok
                            fprintf('OpenMagnetics API interface switched to online mode (%s)\n', obj.online_url);
                            return;
                        end
                    end
                catch
                end
                obj.online_connected = false;
                obj.mode = 'offline';
                obj.apply_offline_data();
                fprintf('OpenMagnetics API interface staying offline (online unavailable)\n');
                return;
            end

            obj.mode = 'offline';
            obj.online_connected = false;
            obj.apply_offline_data();
            fprintf('OpenMagnetics API interface set to offline mode\n');
            ok = true;
        end

        % ======== PUBLIC ACCESSORS ========

        function wires = get_wires(obj)
            wires = obj.wire_database;
        end

        function cores = get_cores(obj)
            cores = obj.core_database;
        end

        function materials = get_materials(obj)
            materials = obj.material_database;
        end

        function suppliers = get_suppliers(obj)
            suppliers = obj.supplier_list;
        end

        function cores = get_cores_by_supplier(obj, supplier)
            safe = strrep(strrep(supplier, '/', '_'), ' ', '_');
            if isfield(obj.supplier_cores, safe)
                cores = obj.supplier_cores.(safe);
            else
                cores = {};
            end
        end

        function mats = get_materials_by_supplier(obj, supplier)
            safe = strrep(strrep(supplier, '/', '_'), ' ', '_');
            if isfield(obj.supplier_materials, safe)
                mats = obj.supplier_materials.(safe);
            else
                mats = {};
            end
        end

        function info = get_wire_info(obj, wire_name)
            if isfield(obj.wire_database, wire_name)
                info = obj.wire_database.(wire_name);
            else
                info = struct('type', 'Unknown', 'diameter', 0.5e-3, ...
                              'area', pi/4*(0.5e-3)^2, 'conductor_shape', 'round');
            end
        end

        function gapping = build_gapping_array(obj, gap_type, gap_length, num_gaps)
            % Build OpenMagnetics gapping array from GUI parameters
            % Maps GUI gap types to OpenMagnetics types:
            %   Ungapped  -> residual (10um)
            %   Ground    -> subtractive (machined)
            %   Spacer    -> additive (spacer inserted)
            %   Distributed -> subtractive with num_gaps > 1
            %
            % Returns: cell array of gap structs for core functionalDescription

            switch gap_type
                case 'Ungapped'
                    gapping = {struct('type', 'residual', 'length', 10e-6)};

                case 'Ground'
                    gapping = {struct('type', 'subtractive', 'length', gap_length)};

                case 'Spacer'
                    gapping = {struct('type', 'additive', 'length', gap_length)};

                case 'Distributed'
                    gapping = {};
                    per_gap = gap_length / max(num_gaps, 1);
                    for i = 1:num_gaps
                        gapping{end+1} = struct('type', 'subtractive', 'length', per_gap);
                    end

                case 'Custom'
                    gapping = {};
                    for i = 1:num_gaps
                        gapping{end+1} = struct('type', 'subtractive', 'length', gap_length);
                    end

                otherwise
                    gapping = {};
            end
        end

        function [w, h, shape] = wire_to_conductor_dims(obj, wire_name)
            % Returns conductor dimensions for PEEC solver
            % Round/Litz: equivalent square side (same area as circle)
            % Foil/Rect: actual width x height
            % Also returns shape: 'round' or 'rectangular'

            wire = obj.get_wire_info(wire_name);

            if isfield(wire, 'conductor_shape')
                shape = wire.conductor_shape;
            else
                shape = 'round';
            end

            if strcmp(shape, 'rectangular')
                % Foil or rectangular: use actual dimensions
                if isfield(wire, 'foil_width') && isfield(wire, 'foil_thickness')
                    w = wire.foil_width;
                    h = wire.foil_thickness;
                elseif isfield(wire, 'rect_width') && isfield(wire, 'rect_height')
                    w = wire.rect_width;
                    h = wire.rect_height;
                elseif isfield(wire, 'width') && isfield(wire, 'thickness')
                    w = wire.width;
                    h = wire.thickness;
                else
                    w = 10e-3;
                    h = 0.1e-3;
                end
            else
                % Round or Litz: equivalent square
                if isfield(wire, 'outer_diameter')
                    d = wire.outer_diameter;
                elseif isfield(wire, 'diameter')
                    d = wire.diameter * 1.12;
                else
                    d = 0.5e-3;
                end
                side = d * sqrt(pi) / 2;  % Equal-area square
                w = side;
                h = side;
            end
        end

        function od = get_wire_outer_diameter(obj, wire_name)
            % Returns outer diameter for visualization (drawing circles)
            wire = obj.get_wire_info(wire_name);
            if isfield(wire, 'outer_diameter')
                od = wire.outer_diameter;
            elseif isfield(wire, 'diameter')
                od = wire.diameter * 1.12;
            else
                od = 0.5e-3;
            end
        end

        function [w, h] = get_wire_visual_dims(obj, wire_name)
            % Returns dimensions for visualization (actual shape dimensions)
            % Round/Litz: returns [od, od]
            % Foil/Rect: returns [width, thickness]
            wire = obj.get_wire_info(wire_name);
            shape = 'round';
            if isfield(wire, 'conductor_shape')
                shape = wire.conductor_shape;
            end

            if strcmp(shape, 'rectangular')
                if isfield(wire, 'foil_width')
                    w = wire.foil_width;
                    h = wire.foil_thickness;
                elseif isfield(wire, 'rect_width')
                    w = wire.rect_width;
                    h = wire.rect_height;
                else
                    w = 10e-3; h = 0.1e-3;
                end
            else
                od = obj.get_wire_outer_diameter(wire_name);
                w = od;
                h = od;
            end
        end

        % ======== ONLINE DATA (OPTIONAL) ========

        function ok = refresh_from_online(obj)
            ok = false;
            if isempty(obj.online_client) || ~obj.online_client.connected
                return;
            end

            try
                % Get wire list (contains wire names and minimal info)
                remote_wires_list = obj.online_client.get_wires();

                % Fetch detailed data for each wire
                fprintf('\nFetching detailed wire data from server...\n');
                remote_wires = obj.fetch_detailed_wires(remote_wires_list);
                fprintf('Fetched %d wires with detailed data\n', length(fieldnames(remote_wires)));

                remote_cores = obj.online_client.get_core_shapes();
                remote_mats = obj.online_client.get_materials();
            catch ME
                fprintf('Error fetching online data: %s\n', ME.message);
                return;
            end

            wire_db = obj.convert_wire_database(remote_wires);
            core_db = obj.convert_core_database(remote_cores);
            mat_db = obj.convert_material_database(remote_mats);

            if isempty(fieldnames(wire_db)) || isempty(fieldnames(core_db)) || isempty(fieldnames(mat_db))
                return;
            end

            obj.wire_database = wire_db;
            obj.core_database = core_db;
            obj.material_database = mat_db;
            obj.cached_wire_database = wire_db;
            obj.cached_core_database = core_db;
            obj.cached_material_database = mat_db;
            obj.cache_loaded = true;
            obj.save_cache();
            obj.init_supplier_index();
            ok = true;
        end

        function detailed_wires = fetch_detailed_wires(obj, wire_list)
            % Fetch detailed data for FOIL wires ONLY using /wire/{name} endpoint
            % Only caches foil/rectangular wires with complete dimensional data
            % Input: wire_list - struct from /wires endpoint (has 'name' field)
            % Output: struct with ONLY foil wires with detailed dimensional data

            detailed_wires = struct();

            if ~isstruct(wire_list)
                return;
            end

            wire_names = fieldnames(wire_list);

            % Identify ONLY foil/rectangular wires for caching
            foil_wires = {};
            for i = 1:length(wire_names)
                key = wire_names{i};
                wire_minimal = wire_list.(key);

                % Check if it's a foil wire ONLY
                is_foil = false;
                if isfield(wire_minimal, 'type')
                    wire_type = wire_minimal.type;
                    if iscell(wire_type)
                        wire_type = wire_type{1};
                    end
                    if ischar(wire_type)
                        is_foil = strcmpi(wire_type, 'foil');
                    end
                end

                if is_foil
                    foil_wires{end+1} = key;
                end
                % Note: Round and Litz wires are NOT added to the cache
            end

            fprintf('Fetching detailed data for %d foil wires ONLY (excluding %d round/litz wires from cache)...\n', ...
                length(foil_wires), length(wire_names) - length(foil_wires));

            % Fetch detailed data only for foil wires
            for i = 1:length(foil_wires)
                key = foil_wires{i};
                wire_minimal = wire_list.(key);

                % Extract the actual wire name (not the sanitized field name)
                if isfield(wire_minimal, 'name')
                    actual_name = wire_minimal.name;
                else
                    actual_name = key;
                end

                try
                    % Query detailed endpoint
                    wire_detailed = obj.online_client.find_wire(actual_name);

                    % Store under sanitized key
                    detailed_wires.(key) = wire_detailed;

                    if mod(i, 10) == 0
                        fprintf('  Fetched %d/%d foil wires...\n', i, length(foil_wires));
                    end
                catch ME
                    % If detailed fetch fails, use minimal data
                    fprintf('  Warning: Could not fetch details for %s: %s\n', actual_name, ME.message);
                    detailed_wires.(key) = wire_minimal;
                end
            end

            fprintf('Detailed wire fetch complete (%d foil wires fetched).\n', length(foil_wires));
        end

        function n_loaded = load_wire_json(obj, json_path)
            % Load wire data from local PyOpenMagnetics JSON export file.
            % This bypasses the HTTP server entirely - much faster and more reliable.
            %
            % Usage:
            %   1. Run: python export_wire_database.py
            %   2. This method auto-loads the resulting JSON on startup
            %
            % The JSON file has flattened wire data with fields like:
            %   conductingWidth (meters), conductingHeight (meters), type, name, etc.

            n_loaded = 0;

            if nargin < 2 || isempty(json_path)
                % Default: look for JSON file next to this .m file
                try
                    here = fileparts(mfilename('fullpath'));
                    json_path = fullfile(here, 'openmagnetics_wire_database.json');
                catch
                    json_path = 'openmagnetics_wire_database.json';
                end
            end

            if ~exist(json_path, 'file')
                return;  % No JSON file, silently skip
            end

            try
                raw = fileread(json_path);
                data = jsondecode(raw);
            catch ME
                fprintf('Warning: Could not read wire JSON file: %s\n', ME.message);
                return;
            end

            if ~isstruct(data)
                return;
            end

            wire_names = fieldnames(data);

            for i = 1:length(wire_names)
                key = wire_names{i};
                wire_raw = data.(key);

                % Normalize using the existing pipeline
                if isfield(wire_raw, 'name')
                    name = wire_raw.name;
                else
                    name = key;
                end

                normalized = obj.normalize_wire(wire_raw, name);
                safe_key = make_valid_name(name);
                obj.wire_database.(safe_key) = normalized;
                n_loaded = n_loaded + 1;
            end

        end

        function n_loaded = load_core_json(obj, json_path)
            % Load core shapes from local PyOpenMagnetics JSON export file.
            n_loaded = 0;

            if nargin < 2 || isempty(json_path)
                try
                    here = fileparts(mfilename('fullpath'));
                    json_path = fullfile(here, 'openmagnetics_core_database.json');
                catch
                    json_path = 'openmagnetics_core_database.json';
                end
            end

            if ~exist(json_path, 'file')
                return;
            end

            try
                raw = fileread(json_path);
                data = jsondecode(raw);
            catch ME
                fprintf('Warning: Could not read core JSON file: %s\n', ME.message);
                return;
            end

            if ~isstruct(data)
                return;
            end

            core_names = fieldnames(data);

            for i = 1:length(core_names)
                key = core_names{i};
                core_raw = data.(key);

                if isfield(core_raw, 'name')
                    name = core_raw.name;
                else
                    name = key;
                end

                safe_key = make_valid_name(name);

                % Build normalized core entry
                entry = struct();
                entry.name = name;

                if isfield(core_raw, 'family')
                    entry.shape = upper(core_raw.family);
                end

                % Dimensions
                if isfield(core_raw, 'dimensions') && isstruct(core_raw.dimensions)
                    entry.dimensions = core_raw.dimensions;
                end

                % Effective parameters
                if isfield(core_raw, 'effectiveArea')
                    entry.Ae = core_raw.effectiveArea;
                end
                if isfield(core_raw, 'effectiveLength')
                    entry.le = core_raw.effectiveLength;
                end
                if isfield(core_raw, 'effectiveVolume')
                    entry.Ve = core_raw.effectiveVolume;
                end

                % Winding window -> bobbin
                if isfield(core_raw, 'windingWindow') && isstruct(core_raw.windingWindow)
                    ww = core_raw.windingWindow;
                    bobbin = struct();
                    if isfield(ww, 'width') && ~isempty(ww.width)
                        bobbin.width = ww.width;
                    end
                    if isfield(ww, 'height') && ~isempty(ww.height)
                        bobbin.height = ww.height;
                    end
                    if isfield(bobbin, 'width') && isfield(bobbin, 'height')
                        entry.bobbin = bobbin;
                    end
                end

                % Overall dimensions
                if isfield(core_raw, 'overallWidth')
                    entry.overall_width = core_raw.overallWidth;
                end
                if isfield(core_raw, 'overallHeight')
                    entry.overall_height = core_raw.overallHeight;
                end

                % Aliases
                if isfield(core_raw, 'aliases')
                    entry.aliases = core_raw.aliases;
                end

                obj.core_database.(safe_key) = entry;
                n_loaded = n_loaded + 1;
            end

        end

        function n_loaded = load_material_json(obj, json_path)
            % Load core materials from local PyOpenMagnetics JSON export file.
            n_loaded = 0;

            if nargin < 2 || isempty(json_path)
                try
                    here = fileparts(mfilename('fullpath'));
                    json_path = fullfile(here, 'openmagnetics_material_database.json');
                catch
                    json_path = 'openmagnetics_material_database.json';
                end
            end

            if ~exist(json_path, 'file')
                return;
            end

            try
                raw = fileread(json_path);
                data = jsondecode(raw);
            catch ME
                fprintf('Warning: Could not read material JSON file: %s\n', ME.message);
                return;
            end

            if ~isstruct(data)
                return;
            end

            mat_names = fieldnames(data);

            for i = 1:length(mat_names)
                key = mat_names{i};
                mat_raw = data.(key);

                if isfield(mat_raw, 'name')
                    name = mat_raw.name;
                else
                    name = key;
                end

                safe_key = make_valid_name(name);
                entry = struct();
                entry.name = name;

                if isfield(mat_raw, 'manufacturer') && ~isempty(mat_raw.manufacturer)
                    entry.manufacturer = mat_raw.manufacturer;
                end
                if isfield(mat_raw, 'type')
                    entry.type = mat_raw.type;
                end
                if isfield(mat_raw, 'family')
                    entry.family = mat_raw.family;
                end
                if isfield(mat_raw, 'initialPermeability') && ~isempty(mat_raw.initialPermeability)
                    entry.initial_permeability = mat_raw.initialPermeability;
                end
                if isfield(mat_raw, 'saturationFluxDensity') && ~isempty(mat_raw.saturationFluxDensity)
                    entry.saturation_flux_density = mat_raw.saturationFluxDensity;
                end
                if isfield(mat_raw, 'curieTemperature') && ~isempty(mat_raw.curieTemperature)
                    entry.curie_temperature = mat_raw.curieTemperature;
                end
                if isfield(mat_raw, 'density') && ~isempty(mat_raw.density)
                    entry.density = mat_raw.density;
                end
                if isfield(mat_raw, 'resistivity') && ~isempty(mat_raw.resistivity)
                    entry.resistivity = mat_raw.resistivity;
                end

                obj.material_database.(safe_key) = entry;
                n_loaded = n_loaded + 1;
            end

        end

        function load_supplier_json(obj, json_path)
            % Load supplier database from local PyOpenMagnetics JSON export file.
            if nargin < 2 || isempty(json_path)
                try
                    here = fileparts(mfilename('fullpath'));
                    json_path = fullfile(here, 'openmagnetics_supplier_database.json');
                catch
                    json_path = 'openmagnetics_supplier_database.json';
                end
            end

            if ~exist(json_path, 'file')
                return;
            end

            try
                raw = fileread(json_path);
                data = jsondecode(raw);
            catch
                return;
            end

            if ~isstruct(data)
                return;
            end

            supplier_names = fieldnames(data);

            % Build supplier list and material mapping
            obj.supplier_list = {};
            obj.supplier_materials = struct();
            obj.supplier_cores = struct();

            for i = 1:length(supplier_names)
                key = supplier_names{i};
                sup = data.(key);

                if isfield(sup, 'name')
                    mfr_name = sup.name;
                else
                    mfr_name = key;
                end

                obj.supplier_list{end+1} = mfr_name;
                safe_key = make_valid_name(mfr_name);

                % Materials for this supplier
                if isfield(sup, 'materials')
                    mats = sup.materials;
                    if iscell(mats)
                        obj.supplier_materials.(safe_key) = mats;
                    elseif ischar(mats)
                        obj.supplier_materials.(safe_key) = {mats};
                    end
                end

                % Find cores that can use this supplier's materials
                % (Core shapes are material-independent, so all cores work
                %  with all materials. List all cores for each supplier.)
                if isfield(obj, 'core_database') && isstruct(obj.core_database)
                    obj.supplier_cores.(safe_key) = fieldnames(obj.core_database);
                end
            end

        end

        function apply_offline_data(obj)
            if ~obj.cache_loaded
                obj.load_cache();
            end
            if obj.cache_loaded
                obj.wire_database = obj.cached_wire_database;
                obj.core_database = obj.cached_core_database;
                obj.material_database = obj.cached_material_database;
            else
                obj.wire_database = obj.init_wire_database();
                obj.core_database = obj.init_core_database();
                obj.material_database = obj.init_material_database();
            end
            obj.init_supplier_index();
        end

        function ok = load_cache(obj)
            ok = false;
            if isempty(obj.cache_path) || ~exist(obj.cache_path, 'file')
                return;
            end
            try
                data = load(obj.cache_path);
            catch
                return;
            end
            if isfield(data, 'wire_database') && isfield(data, 'core_database') && isfield(data, 'material_database')
                obj.cached_wire_database = data.wire_database;
                obj.cached_core_database = data.core_database;
                obj.cached_material_database = data.material_database;
                obj.wire_database = obj.cached_wire_database;
                obj.core_database = obj.cached_core_database;
                obj.material_database = obj.cached_material_database;
                obj.cache_loaded = true;
                ok = true;
            end
        end

        function save_cache(obj)
            if isempty(obj.cache_path)
                return;
            end
            try
                wire_database = obj.cached_wire_database;
                core_database = obj.cached_core_database;
                material_database = obj.cached_material_database;
                save(obj.cache_path, 'wire_database', 'core_database', 'material_database');
            catch
            end
        end

        function path = default_cache_path(obj)
            try
                here = fileparts(mfilename('fullpath'));
                path = fullfile(here, 'openmagnetics_cache.mat');
            catch
                path = 'openmagnetics_cache.mat';
            end
        end

        function db = convert_wire_database(obj, remote)
            db = struct();
            if isempty(remote)
                return;
            end

            if isstruct(remote) && ~isfield(remote, 'name')
                names = fieldnames(remote);
                for i = 1:numel(names)
                    name = names{i};
                    wire = remote.(name);
                    key = make_valid_name(name);
                    db.(key) = obj.normalize_wire(wire, name);
                end
                return;
            end

            if isstruct(remote) && isfield(remote, 'name')
                for i = 1:numel(remote)
                    name = remote(i).name;
                    key = make_valid_name(name);
                    db.(key) = obj.normalize_wire(remote(i), name);
                end
                return;
            end

            if iscell(remote)
                for i = 1:numel(remote)
                    wire = remote{i};
                    if isstruct(wire) && isfield(wire, 'name')
                        name = wire.name;
                    else
                        name = sprintf('Wire_%d', i);
                    end
                    key = make_valid_name(name);
                    db.(key) = obj.normalize_wire(wire, name);
                end
            end
        end

        function out = normalize_wire(obj, wire, name)
            out = struct();
            out.name = name;

            if ~isstruct(wire)
                return;
            end

            if isfield(wire, 'standard'); out.standard = wire.standard; end
            if isfield(wire, 'coating'); out.coating = wire.coating; end
            if isfield(wire, 'type'); out.type = wire.type; end

            shape = '';
            if isfield(wire, 'conductor_shape'); shape = wire.conductor_shape; end
            if isempty(shape) && isfield(wire, 'shape'); shape = wire.shape; end
            if isempty(shape) && isfield(wire, 'type'); shape = wire.type; end

            is_rect = local_contains(shape, 'rect') || local_contains(shape, 'foil') || local_contains(shape, 'planar');
            if is_rect
                out.conductor_shape = 'rectangular';
            else
                out.conductor_shape = 'round';
            end

            d_bare = resolve_dim_value(wire, {'diameter','conducting_diameter','conductingDiameter','conductorDiameter'});
            d_outer = resolve_dim_value(wire, {'outer_diameter','outerDiameter','outer_diameter_total','outerDiameterTotal'});

            % For OpenMagnetics foil wires: conductingWidth = thickness, conductingHeight = width
            % Try standard field names first, then OpenMagnetics convention
            w_rect = resolve_dim_value(wire, {'rect_width','width','foil_width','foilWidth','conducting_height','conductingHeight'});
            h_rect = resolve_dim_value(wire, {'rect_height','height','foil_thickness','foilThickness','conducting_width','conductingWidth'});

            if strcmp(out.conductor_shape, 'rectangular')
                % Check each dimension individually and use fallbacks if needed
                if h_rect == 0
                    [thickness_mm, ~] = parse_foil_dimensions_from_name(name);
                    if thickness_mm > 0
                        h_rect = thickness_mm * 1e-3;
                    end
                end

                if w_rect == 0
                    [~, width_mm] = parse_foil_dimensions_from_name(name);
                    if width_mm > 0
                        w_rect = width_mm * 1e-3;
                    else
                        w_rect = 25.4e-3;
                    end
                end

                if w_rect > 0
                    out.rect_width = w_rect;
                    out.foil_width = w_rect;
                    out.width = w_rect;
                end
                if h_rect > 0
                    out.rect_height = h_rect;
                    out.foil_thickness = h_rect;
                    out.thickness = h_rect;
                end
                if w_rect > 0 && h_rect > 0
                    out.area = w_rect * h_rect;
                end
            else
                if d_bare > 0
                    out.diameter = d_bare;
                end
                if d_outer > 0
                    out.outer_diameter = d_outer;
                elseif d_bare > 0
                    out.outer_diameter = d_bare * 1.12;
                end
                if d_bare > 0
                    out.area = pi/4 * d_bare^2;
                end
            end

            if isfield(wire, 'awg')
                out.awg = wire.awg;
                out.cond_diameter = sprintf('%d AWG', wire.awg);
            elseif d_bare > 0
                out.cond_diameter = sprintf('%.3f mm', d_bare * 1e3);
            end

            if isfield(wire, 'resistance')
                out.resistance = wire.resistance;
            elseif isfield(out, 'area')
                out.resistance = 1 / (5.8e7 * out.area);
            end

        end

        function db = convert_core_database(obj, remote)
            db = struct();
            if isempty(remote)
                return;
            end

            if isstruct(remote) && ~isfield(remote, 'name')
                names = fieldnames(remote);
                for i = 1:numel(names)
                    name = names{i};
                    core = remote.(name);
                    key = make_valid_name(name);
                    db.(key) = obj.normalize_core(core, name);
                end
                return;
            end

            if isstruct(remote) && isfield(remote, 'name')
                for i = 1:numel(remote)
                    name = remote(i).name;
                    key = make_valid_name(name);
                    db.(key) = obj.normalize_core(remote(i), name);
                end
                return;
            end

            if iscell(remote)
                for i = 1:numel(remote)
                    core = remote{i};
                    if isstruct(core) && isfield(core, 'name')
                        name = core.name;
                    else
                        name = sprintf('Core_%d', i);
                    end
                    key = make_valid_name(name);
                    db.(key) = obj.normalize_core(core, name);
                end
            end
        end

        function out = normalize_core(obj, core, name)
            if ~isstruct(core)
                out = struct();
                out.name = name;
                return;
            end
            out = core;
            out.name = name;
            if ~isfield(out, 'manufacturer')
                if isfield(core, 'manufacturer')
                    out.manufacturer = core.manufacturer;
                elseif isfield(core, 'supplier')
                    out.manufacturer = core.supplier;
                elseif isfield(core, 'vendor')
                    out.manufacturer = core.vendor;
                end
            end

            if ~isfield(out, 'bobbin')
                bobbin = struct();
                if isfield(core, 'bobbin')
                    bobbin = core.bobbin;
                elseif isfield(core, 'winding_window')
                    bobbin = normalize_window(core.winding_window);
                elseif isfield(core, 'windingWindow')
                    bobbin = normalize_window(core.windingWindow);
                elseif isfield(core, 'window')
                    bobbin = normalize_window(core.window);
                end

                if isfield(bobbin, 'width') && isfield(bobbin, 'height')
                    out.bobbin = bobbin;
                end
            end
        end

        function db = convert_material_database(obj, remote)
            db = struct();
            if isempty(remote)
                return;
            end

            if isstruct(remote) && ~isfield(remote, 'name')
                names = fieldnames(remote);
                for i = 1:numel(names)
                    name = names{i};
                    mat = remote.(name);
                    key = make_valid_name(name);
                    db.(key) = mat;
                    db.(key).name = name;
                end
                return;
            end

            if isstruct(remote) && isfield(remote, 'name')
                for i = 1:numel(remote)
                    name = remote(i).name;
                    key = make_valid_name(name);
                    db.(key) = remote(i);
                end
                return;
            end

            if iscell(remote)
                for i = 1:numel(remote)
                    mat = remote{i};
                    if isstruct(mat) && isfield(mat, 'name')
                        name = mat.name;
                    else
                        name = sprintf('Material_%d', i);
                    end
                    key = make_valid_name(name);
                    db.(key) = mat;
                    db.(key).name = name;
                end
            end
        end

        % ======== WIRE DATABASE ========

        function db = init_wire_database(obj)
            db = struct();

            % === AWG Round Wire (16 sizes: 10-40 even) ===
            awg_data = [
                10, 2.588e-3, 2.700e-3;
                12, 2.053e-3, 2.160e-3;
                14, 1.628e-3, 1.730e-3;
                16, 1.291e-3, 1.380e-3;
                18, 1.024e-3, 1.100e-3;
                20, 0.812e-3, 0.879e-3;
                22, 0.644e-3, 0.721e-3;
                24, 0.511e-3, 0.573e-3;
                26, 0.405e-3, 0.457e-3;
                28, 0.321e-3, 0.366e-3;
                30, 0.255e-3, 0.294e-3;
                32, 0.202e-3, 0.234e-3;
                34, 0.160e-3, 0.188e-3;
                36, 0.127e-3, 0.152e-3;
                38, 0.101e-3, 0.124e-3;
                40, 0.080e-3, 0.102e-3;
            ];

            for i = 1:size(awg_data, 1)
                awg = awg_data(i, 1);
                d_bare = awg_data(i, 2);
                d_outer = awg_data(i, 3);
                name = sprintf('AWG_%d', awg);
                db.(name).awg = awg;
                db.(name).diameter = d_bare;
                db.(name).outer_diameter = d_outer;
                db.(name).area = pi/4 * d_bare^2;
                db.(name).resistance = 1 / (5.8e7 * pi/4 * d_bare^2);
                db.(name).type = 'Round';
                db.(name).standard = 'NEMA MW 1000 C';
                db.(name).cond_diameter = sprintf('%d AWG', awg);
                db.(name).coating = 'Enamel single build';
                db.(name).conductor_shape = 'round';
            end

            % === Litz Wire (16 variants) ===
            litz_configs = {
                'Litz_50_40',   50,  40, 0.080e-3, 0.854e-3;
                'Litz_50_38',   50,  38, 0.101e-3, 1.043e-3;
                'Litz_50_44',   50,  44, 0.051e-3, 0.551e-3;
                'Litz_100_40', 100,  40, 0.080e-3, 1.353e-3;
                'Litz_100_38', 100,  38, 0.101e-3, 1.708e-3;
                'Litz_100_44', 100,  44, 0.051e-3, 0.864e-3;
                'Litz_200_40', 200,  40, 0.080e-3, 1.913e-3;
                'Litz_200_38', 200,  38, 0.101e-3, 2.415e-3;
                'Litz_200_44', 200,  44, 0.051e-3, 1.222e-3;
                'Litz_400_40', 400,  40, 0.080e-3, 2.706e-3;
                'Litz_400_38', 400,  38, 0.101e-3, 3.416e-3;
                'Litz_400_44', 400,  44, 0.051e-3, 1.729e-3;
                'Litz_660_40', 660,  40, 0.080e-3, 3.476e-3;
                'Litz_660_44', 660,  44, 0.051e-3, 2.220e-3;
                'Litz_1050_44',1050, 44, 0.051e-3, 2.802e-3;
                'Litz_1050_46',1050, 46, 0.040e-3, 2.204e-3;
            };

            for i = 1:size(litz_configs, 1)
                name = litz_configs{i, 1};
                ns = litz_configs{i, 2};
                sawg = litz_configs{i, 3};
                sd = litz_configs{i, 4};
                od = litz_configs{i, 5};

                db.(name).strands = ns;
                db.(name).strand_awg = sawg;
                db.(name).strand_diameter = sd;
                db.(name).outer_diameter = od;
                db.(name).area = ns * pi/4 * sd^2;
                db.(name).resistance = 1 / (5.8e7 * ns * pi/4 * sd^2);
                db.(name).type = 'Litz';
                db.(name).standard = 'IEC 60317-11';
                db.(name).cond_diameter = sprintf('%dx%dAWG', ns, sawg);
                db.(name).coating = 'Served Litz';
                db.(name).conductor_shape = 'round';
            end

            % === Foil Wire (8 variants) ===
            foil_configs = {
                'Foil_0_05x10', 10, 0.05;
                'Foil_0_05x20', 20, 0.05;
                'Foil_0_1x10',  10, 0.1;
                'Foil_0_1x20',  20, 0.1;
                'Foil_0_1x30',  30, 0.1;
                'Foil_0_2x20',  20, 0.2;
                'Foil_0_5x10',  10, 0.5;
                'Foil_0_5x20',  20, 0.5;
            };

            for i = 1:size(foil_configs, 1)
                name = foil_configs{i, 1};
                fw = foil_configs{i, 2} * 1e-3;
                ft = foil_configs{i, 3} * 1e-3;

                db.(name).foil_width = fw;
                db.(name).foil_thickness = ft;
                db.(name).width = fw;
                db.(name).thickness = ft;
                db.(name).area = fw * ft;
                db.(name).outer_diameter = fw;  % Backward compat
                db.(name).resistance = 1 / (5.8e7 * fw * ft);
                db.(name).type = 'Foil';
                db.(name).standard = 'IEC 60317-0-1';
                db.(name).cond_diameter = sprintf('%.1fmm x %.2fmm', fw*1e3, ft*1e3);
                db.(name).coating = 'Kapton tape';
                db.(name).conductor_shape = 'rectangular';
            end

            % === Rectangular Wire (8 variants) ===
            rect_configs = {
                'Rect_2x1',    2, 1;
                'Rect_3x1',    3, 1;
                'Rect_4x1',    4, 1;
                'Rect_5x1',    5, 1;
                'Rect_5x2',    5, 2;
                'Rect_8x1',    8, 1;
                'Rect_10x1',  10, 1;
                'Rect_10x2',  10, 2;
            };

            for i = 1:size(rect_configs, 1)
                name = rect_configs{i, 1};
                rw = rect_configs{i, 2} * 1e-3;
                rh = rect_configs{i, 3} * 1e-3;

                db.(name).rect_width = rw;
                db.(name).rect_height = rh;
                db.(name).width = rw;
                db.(name).thickness = rh;
                db.(name).area = rw * rh;
                db.(name).outer_diameter = rw;  % Backward compat
                db.(name).resistance = 1 / (5.8e7 * rw * rh);
                db.(name).type = 'Rectangular';
                db.(name).standard = 'NEMA MW 1000 C';
                db.(name).cond_diameter = sprintf('%.1fmm x %.1fmm', rw*1e3, rh*1e3);
                db.(name).coating = 'Enamel single build';
                db.(name).conductor_shape = 'rectangular';
            end
        end

        % ======== CORE DATABASE ========

        function db = init_core_database(obj)
            db = struct();

            % ETD Series
            etd = {
                'ETD_29_16_10', 29, 16, 10, 76.0,  72.0,  5470,  'TDK';
                'ETD_34_17_11', 34, 17, 11, 97.1,  78.6,  7640,  'TDK';
                'ETD_39_20_13', 39, 20, 13, 125.0, 92.2,  11500, 'TDK';
                'ETD_44_22_15', 44, 22, 15, 173.0, 103.0, 17800, 'TDK';
                'ETD_49_25_16', 49, 25, 16, 211.0, 114.0, 24100, 'TDK';
                'ETD_54_28_19', 54, 28, 19, 280.0, 127.0, 35600, 'Ferroxcube';
                'ETD_59_31_22', 59, 31, 22, 368.0, 139.0, 51200, 'Ferroxcube';
            };

            for i = 1:size(etd, 1)
                name = etd{i, 1};
                db.(name).shape = 'ETD';
                db.(name).dimensions.A = etd{i,2}*1e-3;
                db.(name).dimensions.B = etd{i,3}*1e-3;
                db.(name).dimensions.C = etd{i,4}*1e-3;
                db.(name).Ae = etd{i,5}*1e-6;
                db.(name).le = etd{i,6}*1e-3;
                db.(name).Ve = etd{i,7}*1e-9;
                db.(name).manufacturer = etd{i,8};
                db.(name).material = 'N87';
                bw = etd{i,2}*0.355e-3; bh = etd{i,4}*1.12e-3;
                db.(name).bobbin.width = bw;
                db.(name).bobbin.height = bh;
            end

            % E Series
            e_cores = {
                'E_20_10_6',  20, 10,  6,  32.0, 42.8,  1370, 'TDK';
                'E_25_13_7',  25, 13,  7,  52.0, 57.5,  2990, 'TDK';
                'E_30_15_7',  30, 15,  7,  60.0, 67.0,  4020, 'TDK';
                'E_36_18_11', 36, 18, 11, 120.0, 72.0,  8640, 'TDK';
                'E_42_21_15', 42, 21, 15, 178.0, 97.0, 17300, 'Ferroxcube';
                'E_55_28_21', 55, 28, 21, 353.0, 124.0, 43800, 'Ferroxcube';
                'E_65_32_27', 65, 32, 27, 540.0, 147.0, 79400, 'Ferroxcube';
                'E_80_38_20', 80, 38, 20, 380.0, 184.0, 69900, 'Magnetics_Inc';
            };

            for i = 1:size(e_cores, 1)
                name = e_cores{i, 1};
                db.(name).shape = 'E';
                db.(name).dimensions.A = e_cores{i,2}*1e-3;
                db.(name).dimensions.B = e_cores{i,3}*1e-3;
                db.(name).dimensions.C = e_cores{i,4}*1e-3;
                db.(name).Ae = e_cores{i,5}*1e-6;
                db.(name).le = e_cores{i,6}*1e-3;
                db.(name).Ve = e_cores{i,7}*1e-9;
                db.(name).manufacturer = e_cores{i,8};
                db.(name).material = 'N87';
                bw = e_cores{i,2}*0.30e-3; bh = e_cores{i,4}*1.35e-3;
                db.(name).bobbin.width = bw;
                db.(name).bobbin.height = bh;
            end

            % PQ Series
            pq = {
                'PQ_20_16', 20, 16, 116.0, 46.3,  5370, 'TDK';
                'PQ_20_20', 20, 20, 116.0, 50.3,  5820, 'TDK';
                'PQ_26_25', 26, 25, 121.0, 58.7,  7100, 'TDK';
                'PQ_32_30', 32, 30, 170.0, 74.8, 12700, 'Ferroxcube';
                'PQ_35_35', 35, 35, 196.0, 87.3, 17100, 'Ferroxcube';
                'PQ_40_40', 40, 40, 201.0, 102.0, 20500, 'Ferroxcube';
            };

            for i = 1:size(pq, 1)
                name = pq{i, 1};
                db.(name).shape = 'PQ';
                db.(name).dimensions.A = pq{i,2}*1e-3;
                db.(name).dimensions.B = pq{i,3}*1e-3;
                db.(name).Ae = pq{i,4}*1e-6;
                db.(name).le = pq{i,5}*1e-3;
                db.(name).Ve = pq{i,6}*1e-9;
                db.(name).manufacturer = pq{i,7};
                db.(name).material = 'N87';
                bw = pq{i,2}*0.30e-3; bh = pq{i,3}*0.40e-3;
                db.(name).bobbin.width = bw;
                db.(name).bobbin.height = bh;
            end

            % RM Series
            rm = {
                'RM_5',    5,   25.0, 28.0,  700,   'TDK';
                'RM_6',    6,   37.0, 28.3,  1045,  'TDK';
                'RM_8',    8,   64.0, 38.2,  2440,  'TDK';
                'RM_10',  10,  110.0, 44.6,  4910,  'TDK';
                'RM_12',  12,  146.0, 52.0,  7590,  'Ferroxcube';
                'RM_14',  14,  200.0, 58.0, 11600,  'Ferroxcube';
            };

            for i = 1:size(rm, 1)
                name = rm{i, 1};
                sz = rm{i, 2};
                db.(name).shape = 'RM';
                db.(name).dimensions.A = sz*1e-3;
                db.(name).Ae = rm{i,3}*1e-6;
                db.(name).le = rm{i,4}*1e-3;
                db.(name).Ve = rm{i,5}*1e-9;
                db.(name).manufacturer = rm{i,6};
                db.(name).material = 'N87';
                bw = sz*0.78e-3; bh = sz*1.0e-3;
                db.(name).bobbin.width = bw;
                db.(name).bobbin.height = bh;
            end

            % EFD Series
            efd = {
                'EFD_15_8_5',   15,  8,  5,  22.0, 34.0,  750,  'TDK';
                'EFD_20_10_7',  20, 10,  7,  31.0, 47.0,  1460, 'TDK';
                'EFD_25_13_9',  25, 13,  9,  58.0, 57.0,  3300, 'Ferroxcube';
                'EFD_30_15_9',  30, 15,  9,  69.0, 68.0,  4690, 'Ferroxcube';
            };

            for i = 1:size(efd, 1)
                name = efd{i, 1};
                db.(name).shape = 'EFD';
                db.(name).dimensions.A = efd{i,2}*1e-3;
                db.(name).dimensions.B = efd{i,3}*1e-3;
                db.(name).dimensions.C = efd{i,4}*1e-3;
                db.(name).Ae = efd{i,5}*1e-6;
                db.(name).le = efd{i,6}*1e-3;
                db.(name).Ve = efd{i,7}*1e-9;
                db.(name).manufacturer = efd{i,8};
                db.(name).material = 'N87';
                bw = efd{i,2}*0.28e-3; bh = efd{i,4}*1.2e-3;
                db.(name).bobbin.width = bw;
                db.(name).bobbin.height = bh;
            end

            % EP Series
            ep = {
                'EP_7',    7,  10.7, 16.5,  176,  'TDK';
                'EP_10',  10,  11.5, 23.8,  274,  'TDK';
                'EP_13',  13,  14.7, 30.3,  445,  'Ferroxcube';
            };

            for i = 1:size(ep, 1)
                name = ep{i, 1};
                sz = ep{i, 2};
                db.(name).shape = 'EP';
                db.(name).dimensions.A = sz*1e-3;
                db.(name).Ae = ep{i,3}*1e-6;
                db.(name).le = ep{i,4}*1e-3;
                db.(name).Ve = ep{i,5}*1e-9;
                db.(name).manufacturer = ep{i,6};
                db.(name).material = 'N87';
                bw = sz*0.6e-3; bh = sz*0.7e-3;
                db.(name).bobbin.width = bw;
                db.(name).bobbin.height = bh;
            end
        end

        % ======== MATERIAL DATABASE ========

        function db = init_material_database(obj)
            db = struct();

            % TDK/EPCOS ferrites
            tdk_mats = {
                'N87',  2200, 0.39, 1.5,  1.3, 2.5, 500, 'TDK';
                'N49',  1500, 0.41, 2.5,  1.1, 2.3, 1000, 'TDK';
                'N97',  2300, 0.41, 1.2,  1.3, 2.5, 500, 'TDK';
                'N27',  2000, 0.41, 4.0,  1.2, 2.2, 300, 'TDK';
                'N30',  4300, 0.38, 0.7,  1.5, 2.7, 200, 'TDK';
                'N72',  3000, 0.35, 2.0,  1.3, 2.4, 150, 'TDK';
            };

            for i = 1:size(tdk_mats, 1)
                name = tdk_mats{i, 1};
                db.(name).mu_initial = tdk_mats{i, 2};
                db.(name).Bsat = tdk_mats{i, 3};
                db.(name).steinmetz_k = tdk_mats{i, 4};
                db.(name).steinmetz_alpha = tdk_mats{i, 5};
                db.(name).steinmetz_beta = tdk_mats{i, 6};
                db.(name).f_max = tdk_mats{i, 7} * 1e3;
                db.(name).manufacturer = tdk_mats{i, 8};
            end

            % Ferroxcube (use x prefix to make valid field names)
            fx_mats = {
                'x3C90', 2300, 0.47, 1.4, 1.3, 2.5, 500, 'Ferroxcube';
                'x3C95', 3000, 0.53, 1.0, 1.4, 2.6, 500, 'Ferroxcube';
                'x3F3',  2000, 0.44, 2.0, 1.2, 2.3, 700, 'Ferroxcube';
                'x3F4',  900,  0.41, 5.0, 1.1, 2.2, 3000, 'Ferroxcube';
                'x3F36', 1800, 0.44, 1.5, 1.3, 2.5, 1000, 'Ferroxcube';
            };

            for i = 1:size(fx_mats, 1)
                name = fx_mats{i, 1};
                db.(name).mu_initial = fx_mats{i, 2};
                db.(name).Bsat = fx_mats{i, 3};
                db.(name).steinmetz_k = fx_mats{i, 4};
                db.(name).steinmetz_alpha = fx_mats{i, 5};
                db.(name).steinmetz_beta = fx_mats{i, 6};
                db.(name).f_max = fx_mats{i, 7} * 1e3;
                db.(name).manufacturer = fx_mats{i, 8};
            end

            % Magnetics Inc
            mag_mats = {
                'P',  2500, 0.50, 1.3, 1.3, 2.5, 500, 'Magnetics_Inc';
                'R',  2300, 0.49, 1.5, 1.3, 2.4, 500, 'Magnetics_Inc';
                'F',  3000, 0.47, 0.9, 1.4, 2.6, 300, 'Magnetics_Inc';
                'W',  10000, 0.44, 0.5, 1.5, 2.7, 100, 'Magnetics_Inc';
                'L',  2500, 0.48, 1.7, 1.3, 2.5, 400, 'Magnetics_Inc';
            };

            for i = 1:size(mag_mats, 1)
                name = mag_mats{i, 1};
                db.(name).mu_initial = mag_mats{i, 2};
                db.(name).Bsat = mag_mats{i, 3};
                db.(name).steinmetz_k = mag_mats{i, 4};
                db.(name).steinmetz_alpha = mag_mats{i, 5};
                db.(name).steinmetz_beta = mag_mats{i, 6};
                db.(name).f_max = mag_mats{i, 7} * 1e3;
                db.(name).manufacturer = mag_mats{i, 8};
            end
        end

        % ======== SUPPLIER INDEXING ========

        function init_supplier_index(obj)
            suppliers = {};

            obj.supplier_cores = struct();
            obj.supplier_materials = struct();

            % Index cores by supplier
            core_names = fieldnames(obj.core_database);
            for c = 1:length(core_names)
                core = obj.core_database.(core_names{c});
                if isfield(core, 'manufacturer')
                    suppliers{end+1} = core.manufacturer; %#ok<AGROW>
                end
            end

            % Index materials by supplier
            mat_names = fieldnames(obj.material_database);
            for m = 1:length(mat_names)
                mat = obj.material_database.(mat_names{m});
                if isfield(mat, 'manufacturer')
                    suppliers{end+1} = mat.manufacturer; %#ok<AGROW>
                end
            end

            if isempty(suppliers)
                obj.supplier_list = {'TDK', 'Ferroxcube', 'Magnetics_Inc'};
            else
                obj.supplier_list = unique(suppliers, 'stable');
            end

            for s = 1:length(obj.supplier_list)
                sup = obj.supplier_list{s};
                safe_sup = strrep(strrep(sup, '/', '_'), ' ', '_');
                obj.supplier_cores.(safe_sup) = {};
                obj.supplier_materials.(safe_sup) = {};
            end

            for c = 1:length(core_names)
                core = obj.core_database.(core_names{c});
                if isfield(core, 'manufacturer')
                    safe_sup = strrep(strrep(core.manufacturer, '/', '_'), ' ', '_');
                    if isfield(obj.supplier_cores, safe_sup)
                        obj.supplier_cores.(safe_sup){end+1} = core_names{c}; %#ok<AGROW>
                    end
                end
            end

            for m = 1:length(mat_names)
                mat = obj.material_database.(mat_names{m});
                if isfield(mat, 'manufacturer')
                    safe_sup = strrep(strrep(mat.manufacturer, '/', '_'), ' ', '_');
                    if isfield(obj.supplier_materials, safe_sup)
                        obj.supplier_materials.(safe_sup){end+1} = mat_names{m}; %#ok<AGROW>
                    end
                end
            end
        end

    end % methods
end

function name = make_valid_name(raw)
    if ~ischar(raw)
        if isa(raw, 'string')
            raw = char(raw);
        else
            raw = 'Unknown';
        end
    end
    name = regexprep(raw, '[^a-zA-Z0-9_]', '_');
    if isempty(name)
        name = 'Unknown';
    end
    if ~isletter(name(1))
        name = ['W_' name];
    end
end

function val = resolve_dim_value(s, keys)
    val = 0;
    for i = 1:numel(keys)
        key = keys{i};
        if isfield(s, key)
            val = extract_numeric(s.(key));
            if val > 0
                return;
            end
        end
    end
end

function val = extract_numeric(v)
    val = 0;
    if isnumeric(v)
        if ~isempty(v)
            val = v(1);
        end
        return;
    end
    if isstruct(v)
        if isfield(v, 'nominal') && isnumeric(v.nominal)
            val = v.nominal;
            return;
        end
        if isfield(v, 'value') && isnumeric(v.value)
            val = v.value;
            return;
        end
        if isfield(v, 'max') && isnumeric(v.max)
            val = v.max;
            return;
        end
        if isfield(v, 'min') && isnumeric(v.min)
            val = v.min;
            return;
        end
    end
end

function win = normalize_window(w)
    win = struct();
    if ~isstruct(w)
        return;
    end
    if isfield(w, 'width')
        win.width = extract_numeric(w.width);
    elseif isfield(w, 'window_width')
        win.width = extract_numeric(w.window_width);
    end
    if isfield(w, 'height')
        win.height = extract_numeric(w.height);
    elseif isfield(w, 'window_height')
        win.height = extract_numeric(w.window_height);
    end
end

function tf = local_contains(str, pattern)
    if ~ischar(str)
        if isa(str, 'string')
            str = char(str);
        else
            tf = false;
            return;
        end
    end
    if ~ischar(pattern)
        if isa(pattern, 'string')
            pattern = char(pattern);
        else
            tf = false;
            return;
        end
    end
    tf = ~isempty(strfind(lower(str), lower(pattern)));
end

function [thickness_mm, width_mm] = parse_foil_dimensions_from_name(name)
    % Parses foil dimensions from wire name
    % OpenMagnetics foil wires are named like: "Foil 0.005", "Foil 0.038", "Foil_0.1", etc.
    % The number represents thickness in millimeters
    % Returns: [thickness_mm, width_mm] (width_mm = 0 if not found)

    thickness_mm = 0;
    width_mm = 0;

    if ~ischar(name)
        return;
    end

    % Look for "Foil" or "foil" in the name
    if isempty(strfind(lower(name), 'foil'))
        return;
    end

    % Try to extract number after "Foil" or "foil"
    % Patterns: "Foil 0.005", "Foil_0.038", "Foil_0_1", etc.

    % Replace underscores and spaces with spaces
    name_normalized = strrep(name, '_', ' ');
    name_normalized = strrep(name_normalized, '.', ' ');

    % Split by spaces
    parts = strsplit(name_normalized);

    % Find "Foil" or "foil" index
    foil_idx = 0;
    for i = 1:length(parts)
        if strcmpi(parts{i}, 'foil')
            foil_idx = i;
            break;
        end
    end

    if foil_idx == 0 || foil_idx >= length(parts)
        % Try simpler regex pattern
        % Match patterns like "Foil_0.005" or "Foil 0.038"
        pattern = '[Ff]oil[_ ]?(\d+\.?\d*)';
        tokens = regexp(name, pattern, 'tokens');
        if ~isempty(tokens) && ~isempty(tokens{1})
            thickness_mm = str2double(tokens{1}{1});
            return;
        end
        return;
    end

    % Try to parse number after "foil"
    num_str = '';
    for i = (foil_idx+1):length(parts)
        if ~isempty(parts{i})
            num_str = [num_str parts{i}];
        end
    end

    if ~isempty(num_str)
        % Reconstruct decimal point if needed
        % "0 005" -> "0.005"
        % "0 1" -> "0.1"
        % "2" -> "2"
        num_parts = strsplit(num_str);
        if length(num_parts) >= 2
            % Has multiple parts - likely separated decimal
            reconstructed = [num_parts{1} '.' strjoin(num_parts(2:end), '')];
            thickness_mm = str2double(reconstructed);
        else
            thickness_mm = str2double(num_str);
        end
    end
end
